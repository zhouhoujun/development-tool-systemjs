{"version":3,"sources":["SystemjsBundle.ts"],"names":["_","require","development_core_1","path","url","fs_1","chalk","replace","Builder","source","vinylBuffer","chksum","mkdirp","SystemjsBundle","_super","info","_this","call","this","name","runWay","RunWay","sequence","manifestSplit","__extends","prototype","ctx","dist","gulp","option","bundles","initBundles","then","Promise","all","map","getBundles","loadBuilder","builder","bundle","bundleConfig","bcfg","getBuildConfig","defaults","config","groupBundle","trans","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","execute","context","bundleMaps","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","setup","initOption","pipes","ps","getAssertResetPipe","length","concat","working","output","bundlemap","modules","push","sfx","bundleName","filename","bundleDest","getOption","baseURL","toUrl","getRootPath","jsbuilder","isArray","systemConfig","first","resolve","cf","loadConfig","undefined","t","stream","opt","pr","to","bundleDeps","pkg","getPackage","packageFile","red","process","exit","deps","dependencies","keys","jspm","depsExclude","exclude_1","isFunction","filter","d","indexOf","isBoolean","deplibs","combine","items","cores","each","n","b","exclude","toModule","bundleBaseDir","s","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundlePaths","paths","getDist","rootpath","getFolders","f","p","env","root","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","minify","mangle","sourceMaps","separateCSS","lowResSourceMaps","toStr","parent","toRootPath","includes","forEach","toRootSrc","toSrc","rootURL","restps","isUndefined","resetAsserts","folders","isString","pth","toDistPath","existsSync","yellow","toDistSrc","ps_1","dist_1","baseURL_1","root_1","relp","fm","basename","reg","RegExp","reg2","reg3","gb","uniq","split","bundleGp","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","key","str","exclusionArray","minus","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","opts","outFile","normalize","bind","sync","dirname","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","template","cssSrc_1","jsonSrc_1","textSrc_1","maps_1","css","json","text","find","it","test","jspmMetas","maps","JSON","stringify","jspmMeta","readFile","data","mainfilePipes","mainfileOutput","content","readFileSync","idx","writeFileSync","e","fullPath","min","name_1","PipeTask","__decorate","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../SystemjsBundle.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport * as url from 'url';\r\nimport { IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n\r\nconst replace = require('gulp-replace');\r\n// const globby = require('globby');\r\nconst Builder = require('systemjs-builder');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class SystemjsBundle extends PipeTask {\r\n\r\n    name = 'systemjs-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<ITaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                let bcfg = this.getBuildConfig(ctx);\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, bcfg);\r\n                                if (bundle.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<ITaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    let bcfg = this.getBuildConfig(ctx);\r\n                    if (bcfg.config) {\r\n                        builder.config(bcfg.config)\r\n                    }\r\n\r\n                    return ctx.fileFilter(src)\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(ctx, files);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<ITaskContext>ctx);\r\n                            return this.createBundler(<ITaskContext>ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <ITaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let pipes = super.pipes(ctx, dist, gulp) || [];\r\n        let ps = this.getAssertResetPipe(ctx);\r\n        if (ps && ps.length > 0) {\r\n            pipes = pipes.concat(ps);\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '';\r\n        let jsbuilder = new Builder(baseURL, _.isArray(option.systemConfig) ? _.first(option.systemConfig) : <string>option.systemConfig);\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (_.isArray(option.systemConfig) && option.systemConfig.length > 1) {\r\n                    return Promise.all(option.systemConfig.map(cf => builder.loadConfig(cf, undefined, true)))\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    protected initBundles(ctx: ITaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = <IBundlesConfig>ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => ctx.to<IMap<IBundleGroup> | Promise<IMap<IBundleGroup>>>(opt.bundles));\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = ctx.getPackage(<string>opt.packageFile);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n\r\n                let deps = opt.dependencies ? ctx.to<string[]>(opt.dependencies) : _.keys(pkg.jspm.dependencies);\r\n                if (!deps || deps.length < 0) {\r\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\r\n                    process.exit(0);\r\n                }\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.keys(bundles), n => {\r\n                            let b: IBundleGroup = bundles[n];\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                            bundleDeps[n] = b;\r\n                        });\r\n\r\n                        return bundleDeps;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    private getRelativeSrc(ctx: ITaskContext, src: Src, toModule = false): string[] {\r\n        let baseURL = <string>(<IBundlesConfig>ctx.option).bundleBaseDir;\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = ctx.toUrl(baseURL, s);\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = ctx.toUrl(baseURL, src);\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend({}, <IBundlesConfig>{\r\n            baseURL: '',\r\n            bundleBaseDir: '.',\r\n            mainfile: 'bundle.js',\r\n            systemConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundlePaths(ctx) {\r\n                let paths: any = {};\r\n                let bundleDest = ctx.getDist();\r\n                let rootpath = <string>option.bundleBaseDir;\r\n                ctx.getFolders(rootpath, (f, d) => {\r\n                    if (f !== bundleDest) {\r\n                        let p = d + '/*';\r\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\r\n                    }\r\n                    return '';\r\n                });\r\n                // let jpk = <string>option.jspmPackages;\r\n                // let jp = path.basename(jpk) + '/*';\r\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\r\n                console.log('paths: ', paths);\r\n                return paths;\r\n            },\r\n            includePackageFiles: [\r\n                'node_modules/systemjs/dist/system-polyfills.src.js',\r\n                'node_modules/systemjs/dist/system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        ctx.option = option;\r\n\r\n        option.baseURL = ctx.toStr(option.baseURL);\r\n        if (!option.bundleBaseDir && ctx.parent) {\r\n            option.bundleBaseDir = ctx.parent.getDist()\r\n        } else if (option.bundleBaseDir) {\r\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\r\n        } else {\r\n            console.log(chalk.red('bundleBaseURL config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        option.includes = option.includes || [];\r\n        (option.includePackageFiles || []).forEach(f => {\r\n            option.includes.push(ctx.toRootPath(f));\r\n        });\r\n\r\n        if (option.systemConfig) {\r\n            option.systemConfig = ctx.toRootSrc(ctx.toSrc(option.systemConfig));\r\n        }\r\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\r\n        option.mainfile = ctx.toStr(option.mainfile);\r\n\r\n        return option;\r\n    }\r\n\r\n    protected getBuildConfig(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.builder.config) {\r\n            option.builder.config = _.extend(option.builder.config || {}, {\r\n                paths: ctx.to<IMap<string>>(option.bundlePaths) || {},\r\n                rootURL: <string>option.bundleBaseDir\r\n            });\r\n        }\r\n\r\n        return option.builder;\r\n    }\r\n\r\n    private restps: Pipe[];\r\n    protected getAssertResetPipe(ctx: ITaskContext) {\r\n        if (!this.restps) {\r\n            let option = <IBundlesConfig>ctx.option;\r\n            if (_.isUndefined(option.resetAsserts)) {\r\n                option.resetAsserts = 'assets';\r\n            }\r\n            if (option.resetAsserts) {\r\n                let folders: string[];\r\n                if (_.isString(option.resetAsserts)) {\r\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\r\n                    if (existsSync(pth)) {\r\n                        folders = ctx.getFolders(pth);\r\n                        folders.push(pth);\r\n                    } else {\r\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'))\r\n                    }\r\n                } else {\r\n                    folders = <string[]>ctx.toDistSrc(option.resetAsserts, this.getInfo());\r\n                }\r\n\r\n                folders = folders || [];\r\n\r\n                let ps = [];\r\n                let dist = ctx.getDist(this.getInfo());\r\n                let baseURL = <string>option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n                let root = ctx.getRootPath();\r\n                _.each(folders, f => {\r\n                    let relp = url.resolve(baseURL,  ctx.toUrl(root, ctx.toUrl(dist, f)));\r\n                    let fm = path.basename(f);\r\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\r\n                    let reg = new RegExp(`(url\\\\((\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg, `url(${relp}`));\r\n                    let reg2 = new RegExp(`(url\\\\(\\\\\\\\'(\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\\\\\'\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\r\n                    let reg3 = new RegExp(`(url\\\\((\"\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\r\n                });\r\n                this.restps = ps;\r\n            } else {\r\n                this.restps = [];\r\n            }\r\n        }\r\n        return this.restps;\r\n    }\r\n\r\n\r\n    protected getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: ITaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: ITaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n\r\n        let opts: any = _.extend({ outFile: bundleDest }, builderCfg || {});\r\n        if (!('normalize' in opts)) {\r\n            opts.normalize = true;\r\n        }\r\n        if (!('lowResSourceMaps' in opts)) {\r\n            opts.lowResSourceMaps = true;\r\n        }\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, opts)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n                // console.log('pipe bundling：', chalk.cyan(output.source));\r\n                // console.log('pipe bundling：', chalk.cyan(output.modules));\r\n                console.log('pipe bundling：', chalk.cyan(bundleName));\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(<string>option.bundleBaseDir || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: ITaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: ITaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\r\n\r\n        let bust = ctx.toStr(option.bust);\r\n        console.log('system bust: ', chalk.cyan(bust));\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = ctx.toStr(option.systemConfigTempl);\r\n\r\n            if (!template) {\r\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = option.bundleMaps || {\r\n                css: '',\r\n                json: '',\r\n                text: ''\r\n            };\r\n\r\n            let cssSrc, jsonSrc, textSrc;\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (!maps.css) {\r\n                    cssSrc = <string>_.find(manifest.bundles[n], (it: string) => /css(.min){0,1}.js$/.test(it));\r\n                    if (cssSrc) {\r\n                        maps.css = cssSrc;\r\n                    }\r\n                }\r\n\r\n                if (!maps.json) {\r\n                    jsonSrc = _.find(manifest.bundles[n], (it: string) => /json(.min){0,1}.js$/.test(it));\r\n                    if (jsonSrc) {\r\n                        maps.json = jsonSrc;\r\n                    }\r\n                }\r\n                if (!maps.text) {\r\n                    textSrc = <string>_.find(manifest.bundles[n], (it: string) => /text(.min){0,1}.js$/.test(it));\r\n                    if (textSrc) {\r\n                        maps.text = textSrc;\r\n                    }\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(null, null, '    '), // option.builder.config ? option.builder.config.paths :\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(f, 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: ITaskContext): string {\r\n        return this.getBundleDest(ctx, <string>(<IBundlesConfig>ctx.option).mainfile);\r\n    }\r\n    private getBundleManifest(ctx: ITaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\r\n            : path.join(ctx.getDist(), bundleName);\r\n\r\n        return ctx.toUrl(<string>(<IBundlesConfig>ctx.option).bundleBaseDir, fullPath)\r\n\r\n    }\r\n\r\n    private getBundleDest(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = ctx.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}