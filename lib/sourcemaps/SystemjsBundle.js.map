{"version":3,"sources":["SystemjsBundle.ts"],"names":["_","require","development_core_1","path","url","fs_1","chalk","replace","Builder","source","vinylBuffer","chksum","mkdirp","babel","SystemjsBundle","_super","info","_this","call","this","name","runWay","RunWay","sequence","manifestSplit","__extends","prototype","ctx","dist","gulp","option","bundles","initBundles","then","Promise","all","map","getBundles","loadBuilder","builder","bundle","bundleConfig","bcfg","getBuildConfig","defaults","config","groupBundle","trans","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","execute","context","bundleMaps","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","setup","initOption","pipes","babelOptions","push","concat","ps","getAssertResetPipe","length","working","output","bundlemap","modules","sfx","bundleName","filename","bundleDest","getOption","baseURL","toUrl","getRootPath","jsbuilder","isArray","systemConfig","first","resolve","cf","loadConfig","undefined","t","stream","opt","pr","to","bundleDeps","pkg","getPackage","packageFile","red","process","exit","deps","dependencies","keys","jspm","depsExclude","exclude_1","isFunction","filter","d","indexOf","isBoolean","deplibs","combine","items","cores","each","n","b","exclude","toModule","bundleBaseDir","s","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundlePaths","paths","getDist","rootpath","getFolders","f","p","env","root","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","presets","plugins","minify","mangle","sourceMaps","separateCSS","lowResSourceMaps","toStr","parent","toRootPath","includes","forEach","toRootSrc","toSrc","rootURL","restps","isUndefined","resetAsserts","folders","isString","pth","toDistPath","existsSync","yellow","toDistSrc","ps_1","dist_1","baseURL_1","root_1","relp","fm","basename","reg","RegExp","reg2","reg3","gb","uniq","split","bundleGp","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","key","str","exclusionArray","minus","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","opts","outFile","normalize","bind","sync","dirname","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","template","cssSrc_1","jsonSrc_1","textSrc_1","maps_1","css","json","text","find","it","test","jspmMetas","maps","JSON","stringify","jspmMeta","readFile","data","mainfilePipes","mainfileOutput","content","readFileSync","idx","writeFileSync","e","fullPath","min","name_1","PipeTask","__decorate","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../SystemjsBundle.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport * as url from 'url';\r\nimport { IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n\r\nconst replace = require('gulp-replace');\r\n// const globby = require('globby');\r\nconst Builder = require('systemjs-builder');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\nconst babel = require('gulp-babel');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class SystemjsBundle extends PipeTask {\r\n\r\n    name = 'systemjs-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<ITaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                let bcfg = this.getBuildConfig(ctx);\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, bcfg);\r\n                                if (bundle.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<ITaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    let bcfg = this.getBuildConfig(ctx);\r\n                    if (bcfg.config) {\r\n                        builder.config(bcfg.config)\r\n                    }\r\n\r\n                    return ctx.fileFilter(src)\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(ctx, files);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<ITaskContext>ctx);\r\n                            return this.createBundler(<ITaskContext>ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <ITaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let pipes = [];\r\n        let option = ctx.option as IBundlesConfig;\r\n        if (option.babelOptions) {\r\n            pipes.push(() => babel(option.babelOptions))\r\n        }\r\n        pipes = pipes.concat(super.pipes(ctx, dist, gulp) || []);\r\n        let ps = this.getAssertResetPipe(ctx);\r\n        if (ps && ps.length > 0) {\r\n            pipes = pipes.concat(ps);\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '';\r\n        let jsbuilder = new Builder(baseURL, _.isArray(option.systemConfig) ? _.first(option.systemConfig) : <string>option.systemConfig);\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (_.isArray(option.systemConfig) && option.systemConfig.length > 1) {\r\n                    return Promise.all(option.systemConfig.map(cf => builder.loadConfig(cf, undefined, true)))\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    protected initBundles(ctx: ITaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = <IBundlesConfig>ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => ctx.to<IMap<IBundleGroup> | Promise<IMap<IBundleGroup>>>(opt.bundles));\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = ctx.getPackage(<string>opt.packageFile);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n\r\n                let deps = opt.dependencies ? ctx.to<string[]>(opt.dependencies) : _.keys(pkg.jspm.dependencies);\r\n                if (!deps || deps.length < 0) {\r\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\r\n                    process.exit(0);\r\n                }\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.keys(bundles), n => {\r\n                            let b: IBundleGroup = bundles[n];\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                            bundleDeps[n] = b;\r\n                        });\r\n\r\n                        return bundleDeps;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    private getRelativeSrc(ctx: ITaskContext, src: Src, toModule = false): string[] {\r\n        let baseURL = <string>(<IBundlesConfig>ctx.option).bundleBaseDir;\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = ctx.toUrl(baseURL, s);\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = ctx.toUrl(baseURL, src);\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend({}, <IBundlesConfig>{\r\n            baseURL: '',\r\n            bundleBaseDir: '.',\r\n            mainfile: 'bundle.js',\r\n            systemConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundlePaths(ctx) {\r\n                let paths: any = {};\r\n                let bundleDest = ctx.getDist();\r\n                let rootpath = <string>option.bundleBaseDir;\r\n                ctx.getFolders(rootpath, (f, d) => {\r\n                    if (f !== bundleDest) {\r\n                        let p = d + '/*';\r\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\r\n                    }\r\n                    return '';\r\n                });\r\n                // let jpk = <string>option.jspmPackages;\r\n                // let jp = path.basename(jpk) + '/*';\r\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\r\n                console.log('paths: ', paths);\r\n                return paths;\r\n            },\r\n            includePackageFiles: [\r\n                'node_modules/systemjs/dist/system-polyfills.src.js',\r\n                'node_modules/systemjs/dist/system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            babelOptions: {\r\n                'presets': ['es2015', 'stage-0', 'react'],\r\n                'plugins': ['transform-es2015-modules-systemjs', 'transform-flow-strip-types']\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        ctx.option = option;\r\n\r\n        option.baseURL = ctx.toStr(option.baseURL) || './';\r\n        if (!option.bundleBaseDir && ctx.parent) {\r\n            option.bundleBaseDir = ctx.parent.getDist()\r\n        } else if (option.bundleBaseDir) {\r\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\r\n        } else {\r\n            console.log(chalk.red('bundleBaseURL config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        option.includes = option.includes || [];\r\n        (option.includePackageFiles || []).forEach(f => {\r\n            option.includes.push(ctx.toRootPath(f));\r\n        });\r\n\r\n        if (option.systemConfig) {\r\n            option.systemConfig = ctx.toRootSrc(ctx.toSrc(option.systemConfig));\r\n        }\r\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\r\n        option.mainfile = ctx.toStr(option.mainfile);\r\n\r\n        return option;\r\n    }\r\n\r\n    protected getBuildConfig(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.builder.config) {\r\n            option.builder.config = _.extend(option.builder.config || {}, {\r\n                paths: ctx.to<IMap<string>>(option.bundlePaths) || {},\r\n                rootURL: <string>option.bundleBaseDir\r\n            });\r\n        }\r\n\r\n        return option.builder;\r\n    }\r\n\r\n    private restps: Pipe[];\r\n    protected getAssertResetPipe(ctx: ITaskContext) {\r\n        if (!this.restps) {\r\n            let option = <IBundlesConfig>ctx.option;\r\n            if (_.isUndefined(option.resetAsserts)) {\r\n                option.resetAsserts = 'assets';\r\n            }\r\n            if (option.resetAsserts) {\r\n                let folders: string[];\r\n                if (_.isString(option.resetAsserts)) {\r\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\r\n                    if (existsSync(pth)) {\r\n                        folders = ctx.getFolders(pth);\r\n                        folders.push(pth);\r\n                    } else {\r\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'))\r\n                    }\r\n                } else {\r\n                    folders = <string[]>ctx.toDistSrc(option.resetAsserts, this.getInfo());\r\n                }\r\n\r\n                folders = folders || [];\r\n\r\n                let ps = [];\r\n                let dist = ctx.getDist(this.getInfo());\r\n                let baseURL = <string>option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n                let root = ctx.getRootPath();\r\n                _.each(folders, f => {\r\n                    let relp = url.resolve(baseURL, ctx.toUrl(root, ctx.toUrl(dist, f)));\r\n                    let fm = path.basename(f);\r\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\r\n                    let reg = new RegExp(`(url\\\\((\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg, `url(${relp}`));\r\n                    let reg2 = new RegExp(`(url\\\\(\\\\\\\\'(\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\\\\\'\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\r\n                    let reg3 = new RegExp(`(url\\\\((\"\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\r\n                });\r\n                this.restps = ps;\r\n            } else {\r\n                this.restps = [];\r\n            }\r\n        }\r\n        return this.restps;\r\n    }\r\n\r\n\r\n    protected getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: ITaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: ITaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx === true) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n\r\n        let opts: any = _.extend({ outFile: bundleDest }, builderCfg || {});\r\n        if (!('normalize' in opts)) {\r\n            opts.normalize = true;\r\n        }\r\n        if (!('lowResSourceMaps' in opts)) {\r\n            opts.lowResSourceMaps = true;\r\n        }\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, opts)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n                // console.log('pipe bundling：', chalk.cyan(output.source));\r\n                // console.log('pipe bundling：', chalk.cyan(output.modules));\r\n                console.log('pipe bundling：', chalk.cyan(bundleName));\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(<string>option.bundleBaseDir || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: ITaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: ITaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\r\n\r\n        let bust = ctx.toStr(option.bust);\r\n        console.log('system bust: ', chalk.cyan(bust));\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = ctx.toStr(option.systemConfigTempl);\r\n\r\n            if (!template) {\r\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = option.bundleMaps || {\r\n                css: '',\r\n                json: '',\r\n                text: ''\r\n            };\r\n\r\n            let cssSrc, jsonSrc, textSrc;\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (!maps.css) {\r\n                    cssSrc = <string>_.find(manifest.bundles[n], (it: string) => /css(.min){0,1}.js$/.test(it));\r\n                    if (cssSrc) {\r\n                        maps.css = cssSrc;\r\n                    }\r\n                }\r\n\r\n                if (!maps.json) {\r\n                    jsonSrc = _.find(manifest.bundles[n], (it: string) => /json(.min){0,1}.js$/.test(it));\r\n                    if (jsonSrc) {\r\n                        maps.json = jsonSrc;\r\n                    }\r\n                }\r\n                if (!maps.text) {\r\n                    textSrc = <string>_.find(manifest.bundles[n], (it: string) => /text(.min){0,1}.js$/.test(it));\r\n                    if (textSrc) {\r\n                        maps.text = textSrc;\r\n                    }\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(null, null, '    '), // option.builder.config ? option.builder.config.paths :\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(f, 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: ITaskContext): string {\r\n        return this.getBundleDest(ctx, <string>(<IBundlesConfig>ctx.option).mainfile);\r\n    }\r\n    private getBundleManifest(ctx: ITaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\r\n            : path.join(ctx.getDist(), bundleName);\r\n\r\n        return ctx.toUrl(<string>(<IBundlesConfig>ctx.option).bundleBaseDir, fullPath)\r\n\r\n    }\r\n\r\n    private getBundleDest(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = ctx.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}